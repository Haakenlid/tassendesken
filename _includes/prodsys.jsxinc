// vim: set ft=javascript:
/* jshint ignore:start */
#include config.jsxinc
#include base64.jsxinc
#include json2.jsxinc
/* jshint ignore:end */

function trim(str) {
  // trim whitespace from string
  return str.replace(/^\s*/, '').replace(/\s*$/, '')
}

function toUnicode(theString) { // lager unicode-entiteter av vanskelige bokstaver, tar en string og returnerer en string
  function charToUnicode(letter) {
    var charCode = ('0000' + letter.charCodeAt(0).toString(16).toUpperCase()).substr(-4, 4);
    return '\\u' + charCode;
  }
  var result = theString;
  result = result.replace(/[\u0080-\uFFFF]/g , charToUnicode);
  result = result.replace(/\\u(201C|201D)/g, "\\u0022"); // fikser feil unicode for fancy hermetegn
  result = result.replace(/\\u(2019|2018)/g, "\\u0092"); // fikser feil unicode for apostrofer
  result = result.replace(/\\u2022/g, "\\u0095"); // fikser feil unicode for bullet
  result = result.replace(/\\u2013/g, "\\u0096"); // fikser feil unicode for tankestrek
  result = result.replace(/\\u2026/g, "..."); // fikser ellipsis
  result = result.replace(/\+/g, "\\u002B"); // fikser pluss
  result = result.replace(/\&/g, "\\u0026"); // fikser &
  return result; // String
}

function serializeObject(obj) {
  // make object serializable
  var pt = Object.prototype.toString.call(obj);
  switch(pt) {
    case '[object global]':
    case '[object String]':
    case '[object Number]':
    case '[object Boolean]':
      return obj
    case '[object Object]':
    case '[object Error]':
      var obj2 = {};
      for (var key in obj)
        obj2[key] = serializeObject(obj[key]);
      return obj2
    case '[object Array]':
      var newarr = [];
      for (var i = 0; i < obj.length; i++)
        newarr[i] = serializeObject(obj[i]);
      return newarr;
    case '[object Story]':
      return '[Story id:' + obj.id + ' ' + obj.contents.substr(0,100) + ']'
    case '[object Image]':
      return '[Image id:' + obj.id + ' ' + obj.itemLink.name + ']'
    default:
      return pt
  }
}

function jsonify(obj) {
  return JSON.stringify(
    serializeObject(obj),
    null,
    config.DEBUG ? 2 : 0
  )
}

function logToFile(message, filename) {
  if (!config.DEBUG) return
  if (!filename) filename='default.log';
  var fp = File(config.logfiles + filename);
  fp.open('w');
  fp.encoding='UTF-8';
  fp.lineFeed='Unix';
  if (typeof message !== 'string') {
    message = jsonify(message);
  }
  var successful = fp.write(message);
  fp.close();
  return successful;
}

function log(message) {
  // log to extendscript console
  if (!config.DEBUG) return
  $.writeln(typeof message === 'string' ? message : jsonify(message))
}

function importerSak(sak, artikkeltype) { // placeholder som skal erstattes med en annen funksjon i skriptet import.jsx
  try {
    var nysak = prodsys.get(sak.pk); // henter sak i prodsys
    var payload = {produsert: prodsys.gammelDeskStatus}
    prodsys.post(sak.pk, payload); // flytter saken til neste status i prodsys
  } catch (e) {
    log(e); // skriver feilmelding til konsollen
  }
}

var prodsys = {};

var http = {};
http.use_mock = function() { return false };
http.dummy_connect = function(request) {
  log('DUMMY REQUEST');
  log(request);
  return {
    status: 100,
    head: 'dummy header',
    body: '{"dummy": true}',
    request: request
  }
}
http.connect = function(request, encoding, host, port) {
  if (this.use_mock(request))
    return this.dummy_connect(request);
  var hostString = host + ':' + port;
  var socket = new Socket();
  socket.encoding = encoding || 'utf8';

  if (socket.open(hostString) === false)
    throw new Error('could not connect to ' + hostString);

  socket.write(request);
  var response = socket.read(99999999);
  socket.close();
  var status = response.match(/^HTTP\/... (\d+)/)[1]
  var parts = response.split('\n\n', 2);
  return {
    status: parseInt(status) || 0,
    head: parts[0] || '',
    body: parts[1] || '',
    request: request
  }
}

var prodsys = {};

prodsys.get    = function(pk, attrs)   { return this.request("GET", pk, null, attrs); }
prodsys.put    = function(pk, payload) { return this.request("PUT", pk, payload || {});};
prodsys.patch  = function(pk, payload) { return this.request("PATCH", pk, payload);};
prodsys.delete = function(pk)          { return this.request("DELETE", pk);};
prodsys.post   = function(payload)     { return this.request("POST", null, payload);};

prodsys.list   = function(attrs)     {
  if (attrs && attrs.status != undefined) {
    try {
      attrs.publication_status__in = attrs.status.join(',');
    } catch (e) {
      attrs.publication_status = attrs.status;
    }
    delete attrs.status;
  }
  return this.request("GET", null, null, attrs);
}

prodsys.request = function(method, pk, payload, attrs){
  var url = (pk === null || pk === undefined)
    ? config.api.ENDPOINT
    : config.api.ENDPOINT + pk + '/'

  if (attrs) {
    var queryString = [];
    for (var key in attrs) {
      queryString.push(key + '=' + attrs[key]);
    }
    url += '?' + queryString.join('&');
  }

  var request = [
    method + " " + url + " HTTP/1.1",
    "Host: " + config.api.HOST,
    "Authorization: Basic " + Base64.encode(config.api.USER + ':' + config.api.PASSWORD),
    "Accept: application/json; indent=2",
    "Connection: close"
  ]

  if (payload) {
    var body = typeof payload === 'string' ? payload : jsonify(payload)
    request = request.concat([
      "Content-Type: application/json; charset=UTF-8",
      "Content-Length: " + body.length,
      "",
      body
    ])
  }
  request.push('\n'); // http requests must end with two newlines

  var response = http.connect(
    request.join('\n'),
    'utf8',
    config.api.HOST,
    config.api.PORT,
  )

  if (response.body) {
    try {
      response.json = JSON.parse(response.body);
      // logToFile(response.body, 'prodsysdata.json');
    } catch (error) {
      log('error: ' + error.message)
      logToFile(response.body, 'fail.json');
      response.json = {};
      response.error = error;
    }
  }
  return response
};



