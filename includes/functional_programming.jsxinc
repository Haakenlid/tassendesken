// Ramda.js inspired functional programming utilities for extendscript

var len = prop('length')
var head = pipe(
  arrayFrom,
  prop(0)
)

var tail = pipe(
  arrayFrom,
  function(arr) {
    return arr.slice(1)
  }
)

function applySpec(spec) {
  // {k: (a -> *)} -> a -> {k: *}
  spec = map(when(complement(is(Function)), applySpec), spec)
  return function(val) {
    return map(function(fn) {
      return fn(val)
    })(spec)
  }
}

var reject = curry(function reject(fn, seq) {
  // reverse filter
  // (a -> bool) -> [a] -> [a]
  return filter(complement(fn), seq)
})

var ifElse = curry(function(cond, thenFn, elseFn, val) {
  // if then else
  // (a -> bool) -> (a -> *) -> (a -> *) -> *
  return cond(val) ? thenFn(val) : elseFn(val)
})

var clamp = curry(function(a, b, c) {
  // clamp value in range between min and max
  // a -> a -> a -> a
  return sort()([a, b, c])[1]
})

var min = curry(function(a, b) {
  // smallest of two
  // a -> a -> a
  return a < b ? a : b
})

var max = curry(function(a, b) {
  // largest of two
  // a -> a -> a
  return a > b ? a : b
})

var converge = curry(function converge(after, fnx, val) {
  // (b,c,.. -> z) -> [(a->b),(a->c),..] -> a -> z
  return pipe(
    map(flip(apply)([val])),
    apply(after)
  )(fnx)
})

var memoSort = curry(
  // Sort function that only evaluates the key function once for each item
  // This is useful for expensive key function evaluation.
  // (a -> b) -> ((b, b) -> 1|0|-1) -> [a] -> [a]
  function(keyfn, sorter, arr) {
    return pipe(
      converge(zip, [map(keyfn), identity]),
      sort(sorter(prop(0))),
      pluck(1)
    )(arr)
  }
)

function all(seq) {
  // [a] -> bool
  for (var i = 0; i < seq.length; i++) if (!seq[i]) return false
  return true
}

function always(val) {
  // a -> (() -> a)
  if (typeof val == 'object') {
    var source = uneval(val)
    return function() {
      return eval(source)
    }
  } else
    return function() {
      return val
    }
}

function any(seq) {
  // [a] -> bool
  for (var i = 0; i < seq.length; i++) if (seq[i]) return true
  return false
}

var apply = curry(function apply(fn, args) {
  // turn variadic function into unary function
  // ((...*) -> *) -> ([*]) -> *
  return fn.apply(this, arrayFrom(args))
})

function append(val) {
  // a -> [*] -> [*, a]
  return function(arr) {
    return arr.slice().concat([val])
  }
}

function arrayFrom(seq) {
  // convert indesign collection specifier or other iterable to Array
  // [*] -> [*]
  if (seq instanceof Array) return seq
  // resolve collection specifier
  if (seq.hasOwnProperty('everyItem')) seq = seq.everyItem()
  if (seq.hasOwnProperty('getElements')) seq = seq.getElements()
  var rv = [],
    n = seq.length
  while (n--) rv[n] = seq[n]
  return rv
}

function ascend(fn) {
  // sorting comparator ascending
  // (a -> c) -> (a, a) -> num
  return function(a, b) {
    var A = fn(a),
      B = fn(b)
    if (A > B) return 1
    if (A == B) return 0
    return -1
  }
}

function assoc(name, val) {
  // (k, v) -> obj -> obj
  var c = {}
  c[name] = val
  return mergeRight(c)
}

function bind(fn, args) {
  // bind function arguments
  return function() {
    return fn.apply(this, args)
  }
}

function both(fn0, fn1) {
  // (a->bool, a->bool) -> a -> bool
  return function(val) {
    return fn0(val) && fn1(val)
  }
}

function call(method) {
  // call function / method
  // k -> {k:(() -> a)} -> a
  // () -> (() -> a) -> a
  return function(obj) {
    return method ? obj[method]() : obj()
  }
}

function chain(sequences) {
  // chain all sequences together
  return reduce(concat, [])(sequences)
}

function complement(fn) {
  // boolean invert function output
  // (* -> bool) -> (* -> bool)
  return function() {
    return !fn.apply(this, arguments)
  }
}

function compose() {
  // function composition left <- right
  // (x -> z, ... , a -> b) -> a -> z
  return pipe.apply(this, reverse(arguments))
}

function concat(a, b) {
  // [*], [*] -> [*]
  return arrayFrom(a).concat(arrayFrom(b))
}

function curry(fn, args) {
  // simple function currying
  // ((a,b,c,...) -> d) -> a -> b -> c -> ... -> d
  var boundArgs = args || []
  return function() {
    var args = concat(boundArgs, arguments)
    if (args.length < fn.length) return curry(fn, args)
    else return fn.apply(this, args)
  }
}

function defaultTo(val0) {
  // a -> b? -> b|a
  return function(val1) {
    return val1 === undefined ? val0 : val1
  }
}

function descend(fn) {
  // sorting comparator descending
  // (a -> c) -> (a, a) -> num
  return flip(ascend(fn))
}

function dotProp(name) {
  // convenience wrapper for dotted paths
  // 'k.k' -> {k:{k:v}} -> v?
  return path(name.split('.'))
}

function drop(n) {
  // drop that supports negative indexing
  // num -> [a] -> [a]
  return function(seq) {
    return n < 0 ? arrayFrom(seq).slice(0, n) : arrayFrom(seq).slice(n)
  }
}

function either(fn0, fn1) {
  // (a->bool, a->bool) -> a -> bool
  return function(val) {
    return fn0(val) || fn1(val)
  }
}

var filter = curry(function filter(fn, obj) {
  // filter
  // (a -> bool) -> [a]|{k:a} -> [a]
  if (!fn) fn = identity
  if (obj.constructor == Object) {
    var rv = {}
    for (var key in obj) fn(obj[key]) && (rv[key] = obj[key])
  } else {
    var arr = arrayFrom(obj)
    var rv = []
    for (var i = 0; i < arr.length; i++) fn(arr[i]) && rv.push(arr[i])
  }
  return rv
})

function find(fn) {
  // (a -> bool) -> [a] -> a|null
  return function(arr) {
    for (var i = 0; i < arr.length; i++) if (fn(arr[i])) return arr[i]
    return null
  }
}

function flip(fn) {
  // flip order of arguments of 2-ary function
  // ((a, b) -> c) -> ((b, a) -> c)
  return curry(function(a, b) {
    return fn(b, a)
  })
}

function has(name) {
  // object has property `name`
  // str -> obj -> bool
  return function(obj) {
    if (isNil(obj)) return false
    if (obj instanceof Object) return name in obj
    return obj.constructor.prototype[name] !== undefined
  }
}

function identity(val) {
  // a -> a
  return val
}

function is(type) {
  // object is instance of constructor `type`
  // type -> ob -> bool
  return function(obj) {
    // taken from ramda implementation
    return (obj != null && obj.constructor === type) || obj instanceof type
  }
}

function isNil(obj) {
  // * -> bool
  return obj === undefined || obj === null
}

function join(sep) {
  // str -> [*] -> str
  return pipe(
    arrayFrom,
    function(arr) {
      return arr.join(sep || '')
    }
  )
}

function keys(obj) {
  // object keys
  // {k:v} -> [k]
  var rv = []
  for (var key in obj) if (obj.hasOwnProperty(key)) rv.push(key)
  return rv
}

var map = curry(function map(fn, obj) {
  // filter
  // (a -> b) -> [a]|{k:a} -> [b]
  if (obj.constructor == Object) {
    var rv = {}
    for (var key in obj) rv[key] = fn(obj[key])
    return rv
  } else {
    var rv = []
    var arr = arrayFrom(obj)
    for (var i = 0; i < arr.length; i++) rv[i] = fn(obj[i])
    return rv
  }
})

var merge = curry(function merge(a, b) {
  // {} -> {} -> {}
  var c = {}
  for (var k in a) c[k] = a[k]
  for (var k in b) c[k] = b[k]
  return c
})

var mergeRight = flip(merge)
//~ function mergeRight(a) {
//~   // {} -> {} -> {}
//~   return function(b) {
//~     return merge(b)(a)
//~   }
//~ }

function path(parts) {
  // nested prop getter
  // [k] -> {k:v} -> v?
  return pipe.apply(this, map(prop)(parts))
}

function pipe() {
  // function composition left -> right
  // (a -> b, ... , x -> z) -> a -> z
  if (arguments.length == 0) return identity
  var f0 = arguments[0]
  var fnx = Array.prototype.slice.call(arguments, 1)
  return function() {
    var val = f0.apply(this, arguments)
    for (var i = 0; i < fnx.length; i++) val = fnx[i](val)
    return val
  }
}

function pluck(name) {
  // pluck single prop
  // k -> [{k:v}] -> [v]
  return map(prop(name))
}

function prop(name) {
  // prop getter
  // k -> {k:v} -> v?
  return function(obj) {
    return has(name)(obj) ? obj[name] : undefined
  }
}

function propEq(name, value) {
  // (k, v) -> {k: v} -> bool
  return pipe(
    dotProp(name),
    eq(value)
  )
}

function propOr(name, value) {
  // prop getter with default value
  // (k, v) -> {k:v} -> v
  return function(obj) {
    return has(name)(obj) ? obj[name] : value
  }
}

function reduce(fn, acc) {
  // reduce
  // (((a, b) -> b), a) -> [b] -> a
  return function(seq) {
    var arr = arrayFrom(seq)
    if (typeof acc == 'undefined') acc = arr.shift()
    for (var i = 0; i < arr.length; i++) acc = fn(acc, arr[i])
    return acc
  }
}

function reverse(seq) {
  // reverse collection. returns Array
  // [*] -> [*]
  return arrayFrom(seq).reverse()
}

function setAttr(name, val) {
  // mutating / inpure assoc
  // (k, v) -> obj -> obj
  return function(obj) {
    obj[name] = val
    return obj
  }
}

function sort(fn) {
  // sort
  // ?((a, a) -> num) -> [a] -> [a]
  if (!fn) fn = ascend(identity)
  return function(seq) {
    return arrayFrom(seq).sort(fn)
  }
}

var take = curry(function take(n, seq) {
  // take that supports negative indexing
  // num -> [a] -> [a]
  return n < 0 ? arrayFrom(seq).slice(n) : arrayFrom(seq).slice(0, n)
})

function tap(fn) {
  // For numroducing side effects such as logging numo function pipe line
  // (a -> b) -> (* -> *) -> (a -> b)
  return function(val) {
    fn(val)
    return val
  }
}

function unapply(fn) {
  // make unary function variadic
  // (([*]) -> *) -> ((...*) -> *)
  return function() {
    return fn(arrayFrom(arguments))
  }
}

function uniq(arr) {
  // remove duplicates
  // [*] -> [*]
  var rv = []
  var memo = {}
  for (var i = 0; i < arr.length; i++) {
    var val = arr[i]
    var key = uneval(val)
    if (key in memo) continue;
    memo[key] = true
    rv.push(val)
  }
  return rv
}

function values(obj) {
  // object items
  // {k:v} -> [v]
  var rv = []
  for (var key in obj) if (obj.hasOwnProperty(key)) rv.push(obj[key])
  return rv
}

function when(cond, then) {
  // conditional in pipeline
  // (a -> bool, a -> b) -> a -> a|b
  return function(val) {
    return cond(val) ? then(val) : val
  }
}

function withDefault(fn, val) {
  // (* -> b?, a) -> * -> b|a
  return pipe(
    fn,
    defaultTo(val)
  )
}

function zip() {
  // zip multiple input arrays / sequences
  // ([a], [b], ...) -> [[a, b, ...]]
  var arrs = map(arrayFrom)(arguments)
  var length = pipe(
    pluck('length'),
    sort(),
    prop(0)
  )(arrs)
  rv = []
  for (i = 0; i < length; i++) rv.push(pluck(i)(arrs))
  return rv
}

// functional utility basics

function T() {
  // () -> bool
  return true
}

function F() {
  // () -> bool
  return false
}

// comparison operators

// comparison operators
var eq = curry(function eq(a, b) {
  // a -> a -> bool
  if (is(Object)(a)) {
    for (key in a) if (!propEq(key, a[key])(b)) return false
    return true
  } else return uneval(a) == uneval(b)
})

var neq = curry(function neq(a, b) {
  // a -> a -> bool
  return complement(eq)(a, b)
})

var gt = curry(function gt(a, b) {
  // a -> a -> bool
  return b > a
})

var lt = curry(function lt(a, b) {
  // a -> a -> bool
  return b < a
})

var gte = curry(function gte(a, b) {
  // a -> a -> bool
  return b >= a
})

var lte = curry(function lte(a, b) {
  // a -> a -> bool
  return b <= a
})

// logical operators
function not(val) {
  // b -> bool
  return !val
}

// arithmetic operators
var add = curry(function add(a, b) {
  // num -> num -> num
  // str|* -> *|str -> str
  return b + a
})

var sub = curry(function sub(a, b) {
  // num -> num -> num
  return b - a
})

var mul = curry(function mul(a, b) {
  // num -> num -> num
  return b * a
})

var div = curry(function div(a, b) {
  // num -> num -> num
  return b / a
})

var mod = curry(function mod(a, b) {
  // num -> num -> num
  return b % a
})

var pow = curry(function pow(a, b) {
  // num -> num -> num
  return Math.pow(b, a)
})

// string functions
var replace = curry(function(regex, rep, s) {
  return ('' + s).replace(regex, rep)
})
var match = curry(function(regex, s) {
  return eval(uneval(('' + s).match(regex) || []))
})
var test = curry(function(regex, s) {
  return regex.test('' + s)
})
var split = curry(function(where, s) {
  return ('' + s).split(where)
})
var trim = function(s) {
  return ('' + s).replace(/^\s+/, '').replace(/\s+$/, '')
}
var toTitle = function(s) {
  return s.substr(0, 1).toUpperCase() + s.substr(1).toLowerCase()
}
var toUpper = function(s) {
  return ('' + s).toUpperCase()
}
var toLower = function(s) {
  return ('' + s).toLowerCase()
}

// vi: ft=javascript
